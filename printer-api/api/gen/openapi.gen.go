// Package gen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package gen

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
)

// Defines values for PrinterTransport.
const (
	PrinterTransportNetwork PrinterTransport = "network"
	PrinterTransportUsb     PrinterTransport = "usb"
)

// Defines values for PrinterStatusTransport.
const (
	PrinterStatusTransportNetwork PrinterStatusTransport = "network"
	PrinterStatusTransportUsb     PrinterStatusTransport = "usb"
)

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error struct {
		Message string `json:"message"`
		Type    string `json:"type"`
	} `json:"error"`
}

// NetworkRef defines model for NetworkRef.
type NetworkRef struct {
	Ip   string  `json:"ip"`
	Mac  *string `json:"mac,omitempty"`
	Port int     `json:"port"`
}

// PrintRequest defines model for PrintRequest.
type PrintRequest struct {
	Cut       *bool      `json:"cut,omitempty"`
	Drawer    *bool      `json:"drawer,omitempty"`
	Feed      *int       `json:"feed,omitempty"`
	RawBase64 *string    `json:"rawBase64,omitempty"`
	Text      *TextPrint `json:"text,omitempty"`
	union     json.RawMessage
}

// PrintRequest0 defines model for .
type PrintRequest0 = interface{}

// PrintRequest1 defines model for .
type PrintRequest1 = interface{}

// Printer defines model for Printer.
type Printer struct {
	Id        string             `json:"id"`
	Labels    *map[string]string `json:"labels,omitempty"`
	Network   *NetworkRef        `json:"network,omitempty"`
	StableId  *string            `json:"stableId,omitempty"`
	Transport PrinterTransport   `json:"transport"`
	Usb       *USBRef            `json:"usb,omitempty"`
}

// PrinterTransport defines model for Printer.Transport.
type PrinterTransport string

// PrinterStatus defines model for PrinterStatus.
type PrinterStatus struct {
	Flags     *map[string]bool       `json:"flags,omitempty"`
	Online    bool                   `json:"online"`
	Raw       *map[string]int        `json:"raw,omitempty"`
	Transport PrinterStatusTransport `json:"transport"`
}

// PrinterStatusTransport defines model for PrinterStatus.Transport.
type PrinterStatusTransport string

// QueueStatus defines model for QueueStatus.
type QueueStatus struct {
	Active    bool `json:"active"`
	Capacity  int  `json:"capacity"`
	Queued    int  `json:"queued"`
	Supported bool `json:"supported"`
}

// TextPrint defines model for TextPrint.
type TextPrint struct {
	Bold    *bool    `json:"bold,omitempty"`
	Center  *bool    `json:"center,omitempty"`
	DoubleH *bool    `json:"doubleH,omitempty"`
	DoubleW *bool    `json:"doubleW,omitempty"`
	Lines   []string `json:"lines"`
}

// USBRef defines model for USBRef.
type USBRef struct {
	Manufacturer *string `json:"manufacturer,omitempty"`
	Pid          int     `json:"pid"`
	Product      *string `json:"product,omitempty"`
	Serial       *string `json:"serial,omitempty"`
	Vid          int     `json:"vid"`
}

// PrinterId defines model for PrinterId.
type PrinterId = string

// BadGateway defines model for BadGateway.
type BadGateway = ErrorResponse

// BadRequest defines model for BadRequest.
type BadRequest = ErrorResponse

// DiscoverPrintersParams defines parameters for DiscoverPrinters.
type DiscoverPrintersParams struct {
	// Network Enable network discovery
	Network *bool `form:"network,omitempty" json:"network,omitempty"`

	// Usb Enable USB discovery
	Usb *bool `form:"usb,omitempty" json:"usb,omitempty"`

	// TimeoutMs TCP dial timeout in milliseconds
	TimeoutMs *int `form:"timeoutMs,omitempty" json:"timeoutMs,omitempty"`

	// MaxHosts Max hosts to scan per subnet
	MaxHosts *int `form:"maxHosts,omitempty" json:"maxHosts,omitempty"`

	// Ports Comma-separated list of ports (e.g., 9100,9101)
	Ports *string `form:"ports,omitempty" json:"ports,omitempty"`

	// Hosts Last-octet host filter list/ranges (e.g., 1,5,10,10-120)
	Hosts *string `form:"hosts,omitempty" json:"hosts,omitempty"`
}

// PrintJSONRequestBody defines body for Print for application/json ContentType.
type PrintJSONRequestBody = PrintRequest

// AsPrintRequest0 returns the union data inside the PrintRequest as a PrintRequest0
func (t PrintRequest) AsPrintRequest0() (PrintRequest0, error) {
	var body PrintRequest0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrintRequest0 overwrites any union data inside the PrintRequest as the provided PrintRequest0
func (t *PrintRequest) FromPrintRequest0(v PrintRequest0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrintRequest0 performs a merge with any union data inside the PrintRequest, using the provided PrintRequest0
func (t *PrintRequest) MergePrintRequest0(v PrintRequest0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPrintRequest1 returns the union data inside the PrintRequest as a PrintRequest1
func (t PrintRequest) AsPrintRequest1() (PrintRequest1, error) {
	var body PrintRequest1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrintRequest1 overwrites any union data inside the PrintRequest as the provided PrintRequest1
func (t *PrintRequest) FromPrintRequest1(v PrintRequest1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrintRequest1 performs a merge with any union data inside the PrintRequest, using the provided PrintRequest1
func (t *PrintRequest) MergePrintRequest1(v PrintRequest1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PrintRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Cut != nil {
		object["cut"], err = json.Marshal(t.Cut)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'cut': %w", err)
		}
	}

	if t.Drawer != nil {
		object["drawer"], err = json.Marshal(t.Drawer)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'drawer': %w", err)
		}
	}

	if t.Feed != nil {
		object["feed"], err = json.Marshal(t.Feed)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'feed': %w", err)
		}
	}

	if t.RawBase64 != nil {
		object["rawBase64"], err = json.Marshal(t.RawBase64)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rawBase64': %w", err)
		}
	}

	if t.Text != nil {
		object["text"], err = json.Marshal(t.Text)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *PrintRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["cut"]; found {
		err = json.Unmarshal(raw, &t.Cut)
		if err != nil {
			return fmt.Errorf("error reading 'cut': %w", err)
		}
	}

	if raw, found := object["drawer"]; found {
		err = json.Unmarshal(raw, &t.Drawer)
		if err != nil {
			return fmt.Errorf("error reading 'drawer': %w", err)
		}
	}

	if raw, found := object["feed"]; found {
		err = json.Unmarshal(raw, &t.Feed)
		if err != nil {
			return fmt.Errorf("error reading 'feed': %w", err)
		}
	}

	if raw, found := object["rawBase64"]; found {
		err = json.Unmarshal(raw, &t.RawBase64)
		if err != nil {
			return fmt.Errorf("error reading 'rawBase64': %w", err)
		}
	}

	if raw, found := object["text"]; found {
		err = json.Unmarshal(raw, &t.Text)
		if err != nil {
			return fmt.Errorf("error reading 'text': %w", err)
		}
	}

	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Health check
	// (GET /healthz)
	Healthz(w http.ResponseWriter, r *http.Request)
	// Metrics snapshot
	// (GET /metrics)
	Metrics(w http.ResponseWriter, r *http.Request)
	// Discover printers
	// (GET /v1/printers/discover)
	DiscoverPrinters(w http.ResponseWriter, r *http.Request, params DiscoverPrintersParams)
	// Get printer by ID
	// (GET /v1/printers/{id})
	GetPrinter(w http.ResponseWriter, r *http.Request, id PrinterId)
	// Print a job
	// (POST /v1/printers/{id}/print)
	Print(w http.ResponseWriter, r *http.Request, id PrinterId)
	// Queue info (stateless)
	// (GET /v1/printers/{id}/queue)
	GetQueue(w http.ResponseWriter, r *http.Request, id PrinterId)
	// Get printer status
	// (GET /v1/printers/{id}/status)
	GetPrinterStatus(w http.ResponseWriter, r *http.Request, id PrinterId)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Health check
// (GET /healthz)
func (_ Unimplemented) Healthz(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Metrics snapshot
// (GET /metrics)
func (_ Unimplemented) Metrics(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Discover printers
// (GET /v1/printers/discover)
func (_ Unimplemented) DiscoverPrinters(w http.ResponseWriter, r *http.Request, params DiscoverPrintersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get printer by ID
// (GET /v1/printers/{id})
func (_ Unimplemented) GetPrinter(w http.ResponseWriter, r *http.Request, id PrinterId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Print a job
// (POST /v1/printers/{id}/print)
func (_ Unimplemented) Print(w http.ResponseWriter, r *http.Request, id PrinterId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Queue info (stateless)
// (GET /v1/printers/{id}/queue)
func (_ Unimplemented) GetQueue(w http.ResponseWriter, r *http.Request, id PrinterId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get printer status
// (GET /v1/printers/{id}/status)
func (_ Unimplemented) GetPrinterStatus(w http.ResponseWriter, r *http.Request, id PrinterId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// Healthz operation middleware
func (siw *ServerInterfaceWrapper) Healthz(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Healthz(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Metrics operation middleware
func (siw *ServerInterfaceWrapper) Metrics(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Metrics(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DiscoverPrinters operation middleware
func (siw *ServerInterfaceWrapper) DiscoverPrinters(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DiscoverPrintersParams

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", r.URL.Query(), &params.Network)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "network", Err: err})
		return
	}

	// ------------- Optional query parameter "usb" -------------

	err = runtime.BindQueryParameter("form", true, false, "usb", r.URL.Query(), &params.Usb)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "usb", Err: err})
		return
	}

	// ------------- Optional query parameter "timeoutMs" -------------

	err = runtime.BindQueryParameter("form", true, false, "timeoutMs", r.URL.Query(), &params.TimeoutMs)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "timeoutMs", Err: err})
		return
	}

	// ------------- Optional query parameter "maxHosts" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxHosts", r.URL.Query(), &params.MaxHosts)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "maxHosts", Err: err})
		return
	}

	// ------------- Optional query parameter "ports" -------------

	err = runtime.BindQueryParameter("form", true, false, "ports", r.URL.Query(), &params.Ports)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ports", Err: err})
		return
	}

	// ------------- Optional query parameter "hosts" -------------

	err = runtime.BindQueryParameter("form", true, false, "hosts", r.URL.Query(), &params.Hosts)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hosts", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DiscoverPrinters(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPrinter operation middleware
func (siw *ServerInterfaceWrapper) GetPrinter(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id PrinterId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPrinter(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Print operation middleware
func (siw *ServerInterfaceWrapper) Print(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id PrinterId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Print(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetQueue operation middleware
func (siw *ServerInterfaceWrapper) GetQueue(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id PrinterId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetQueue(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPrinterStatus operation middleware
func (siw *ServerInterfaceWrapper) GetPrinterStatus(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id PrinterId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPrinterStatus(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/healthz", wrapper.Healthz)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/metrics", wrapper.Metrics)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/printers/discover", wrapper.DiscoverPrinters)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/printers/{id}", wrapper.GetPrinter)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v1/printers/{id}/print", wrapper.Print)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/printers/{id}/queue", wrapper.GetQueue)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/printers/{id}/status", wrapper.GetPrinterStatus)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"CAtvWBgAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
